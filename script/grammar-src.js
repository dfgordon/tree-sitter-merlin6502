// `script/gammar-src.js` is for human editing
// `grammar.js` is generated by `opcode_processor.py`

// Downstream tools must resolve the following:
// * limitations on use of local labels
// * 6502 vs. 65C02 opcodes
// * 8 vs. 16 bit psuedo-opcodes

// Do not set this flag manually, let `build.py` handle it
const allow_lower_case = true;
const language_name = allow_lower_case ? 'merlin6502' : 'merlin6502casesens';

// Define constants DO NOT EDIT

// Tree-sitter grammar definition

module.exports = grammar({
	name: language_name,
	extras: $ => [],

	rules: {
		source_file: $ => repeat($._factor),
		_factor: $ => choice(
			$.program_counter,
			$.main_comment,
			$.macro_def,
			$.macro_callx,
			$.macro_calli,
			$.operation,
			$.pseudo_operation, // excludes macro pseudo-ops
			$._newline
		),
		program_counter: $ => seq($._label,optional(seq($._sep,$.comment)),$._newline), // set label to program counter

		// Macros
		macro_def: $ => seq($.macro_start,repeat($.macro_line),$.macro_end),
		macro_start: $ => seq($._label,$._sep,$.psop_mac,optional(seq($._sep,$.comment)),$._newline),
		macro_line: $ => choice($.program_counter,$.main_comment,$.operation,$.pseudo_operation,$.macro_start,$.macro_callx,$.macro_calli,$._newline),
		macro_end: $ => seq(optional($._label),$._sep,$.psop_eom,optional(seq($._sep,$.comment)),$._newline),
		macro_callx: $ => seq(optional($._label),$._sep,$.psop_pmc,$._sep,$._label,optional(seq($._arg_sep,$.macro_args)),optional(seq($._sep,$.comment)),$._newline),
		macro_calli: $ => seq(optional($._label),$._sep,$.global_label,optional(seq($._sep,$.macro_args)),optional(seq($._sep,$.comment)),$._newline),

		_newline: $ => seq(optional($._sep),/\r?\n/),
		_sep: $ => /[ \t]+/,
		_arg_sep: $ => choice('.',',','/','-','(',' '), // separates macro call from arguments in the long form, e.g., PMC mymacro,myargs

		_label: $ => choice($.global_label,$.local_label,$.var_label),
		global_label: $ => token(seq(GLOB_LAB_BEG,repeat(LAB_CHAR))), // max 13 (8bit) or 26 (16bit)
		local_label: $ => token(seq(':',repeat1(LAB_CHAR))), // max 13 (8bit) or 26 (16bit),cannot be first label in program,in macro,MAC,ENT,EXT, or EQU
		var_label: $ => token(seq(']',repeat1(LAB_CHAR))),

		// Operations DO NOT EDIT

		// Pseudo-operations DO NOT EDIT

		// Macro Primitives

		macro_args: $ => seq($.arg,repeat(seq(';',$.arg))),
		arg: $ => repeat1(ARG),

		// Strings

		_string_operand: $ => seq($.dstring,optional(seq(',',$.hex_data))),
		// TODO: MERLIN dstrings can use any delimiter, with related rules about ascii bit 7
		// MERLIN also allows unterminated strings which we do not at present.
		dstring: $ => choice(
			seq('"',repeat(NCHAR),'"'),
			seq("'",repeat(PCHAR),"'")
		),

		// Addressing Modes

		rel: $ => $._aexpr,
		imm: $ => seq($.imm_prefix,$._aexpr),
		addr: $ => $._aexpr,
		addr_x: $ => seq($._aexpr,$.mode_x),
		addr_y: $ => seq($._aexpr,$.mode_y),
		iaddr_ix: $ => seq($.mode_iopen,$._aexpr,$.mode_iix),
		iaddr_y: $ => seq($.mode_iopen,$._aexpr,$.mode_iy),
		iaddr: $ => seq($.mode_iopen,$._aexpr,$.mode_iclose),

		mode_x: $ => ',X',
		mode_y: $ => ',Y',
		mode_iopen: $ => '(',
		mode_iclose: $ => ')',
		mode_iix: $ => ',X)',
		mode_iy: $ => '),Y',

		// Expressions

		_eaexpr: $ => seq(optional($.imm_prefix),$._aexpr),
		_aexpr: $ => choice(
			$._label,
			$.number,
			$.pchar,
			$.nchar,
			$.current_addr,
			$.unary_aexpr,
			$.binary_aexpr
		),
		unary_aexpr: $ => prec(1,choice(seq($.eop_plus,$._aexpr),seq($.eop_minus,$._aexpr))),
		// MERLIN has no operator precedence: left to right always prevails
		binary_aexpr: $ => prec.left(seq($._aexpr,choice(
			$.eop_plus,$.eop_minus,$.eop_times,$.eop_div,$.eop_or,$.eop_and,$.eop_xor
		),$._aexpr)),

		eop_plus: $ => '+',
		eop_minus: $ => '-',
		eop_times: $ => '*',
		eop_div: $ => '/',
		eop_or: $ => '.',
		eop_and: $ => '&',
		eop_xor: $ => '!',

		// Primitive Expressions

		imm_prefix: $ => choice('#','#<','#>','#^'),
		hex_byte: $ => /[0-9A-Fa-f][0-9A-Fa-f]/,
		hex_data: $ => seq($.hex_byte,repeat(seq(optional(','),$.hex_byte))),
		filename: $ => repeat1(ANYCHAR),

		number: $ => choice($.decimal,$.hexadecimal,$.binary),
		decimal: $ => repeat1(/[0-9]/),
		hexadecimal: $ => seq('$',repeat1(/[0-9A-Fa-f]/)),
		binary: $ => seq('%',repeat1(/[01]/)),

		schar: $ => PCHAR,
		pchar: $ => seq("'",PCHAR,optional("'")),
		nchar: $ => seq('"',NCHAR,optional('"')),

		current_addr: $ => '*',

		force: $ => SPCHAR, // more restrictive than Merlin

		literal: $ => /.*/,

		// Comments

		comment: $ => seq(';',$.comment_text), // max 64 - len(operand)
		comment_text: $ => /.*/,
		main_comment: $ => seq(/\s*\*.*/,$._newline) // max 64
	}
});
